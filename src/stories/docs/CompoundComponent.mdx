import { Meta } from '@storybook/blocks'
import { Title } from '@stories/Title'

<Meta title="Contributing/Compound Component" />

# Compound component

If your organism is composed of more than one visual element (component), you MUST implement it using the
`compound component pattern`.

> The compound component pattern typically comes in handy with larger components that have related child components that we also want to configure.
> Instead of having props defined on the main wrapper of your organism that exist just to pass down to its internal children, we render the children directly.

**The compound component pattern is the pattern to use when creating a new Brikke
organism. We took a Popover organism as an example in the following section, but this
pattern can be applied to any organism.**

<Title label="Using a compound component" />

```jsx title="/src/MyPage/MyPopover/index.tsx"
import { Popover } from '@ds-name-to-define/popover'

const MyPopover = () => {
  return (
    <Popover>
      <Popover.Trigger>
        <button type="button">See conditions</button>
      </Popover.Trigger>

      <Popover.Overlay />

      <Popover.Content>
        <Popover.Arrow />
        <Popover.CloseButton />
        <h3>Condition:</h3>
        <p>Officia adipisicing enim id aute nostrud enim eiusmod ea in laboris.</p>
      </Popover.Content>
    </Popover>
  )
}
```

<Title label="Implementation" />

```jsx title="/packages/tabs/src/index.tsx"
import { TabsList as List } from './List'
import { TabsTrigger as Trigger } from './Trigger'
import { TabsContent as Content } from './Content'
import { TabsRoot as Root } from './Root'

// we have to override the "displayName" values here,
// in order to make it work with ReactLiveBlock
Root.displayName = 'Tabs' // <-  the Root Component must be the first to be set ðŸ¤·
Trigger.displayName = 'Tabs.Trigger'
List.displayName = 'Tabs.List'
Content.displayName = 'Tabs.Content'

export const Tabs = Object.assign(Root, {
  List,
  Trigger,
  Content,
})
```

<Title label="Explanation" />

- `Tabs` is the Main wrapper. It acts as a context provider so that its children can communicate with each other without relying on props. The context is optional, for simpler organisms, you might not need it.
- `Object.assign` is then used to attach molecules to the compound organism `Tabs`. It allows us to do `<Tabs.List />, <Tabs.Trigger />, etc` to use an atom. Note that typescript likes this approach better and merge the types correctly without explicit typing.
- **No `default` export**. This is for better discoverability.
  See [why in details](https://basarat.gitbook.io/typescript/main-1/defaultisbad). Optionally, this is where you can also export your types/constants.

<Title label="Benefits" />

<Title label="Discoverability" heading="h3" />

- Typing "`Tabs.`" will autocomplete the molecules to the developer. He/she does not need to know their name to discover them (`Tabs.List`, `Tabs.Trigger`, etc).
- The JSDoc comments above each atom will be visible in the IDE.
- A link to the ZeroHeight specifications is accessible from the main wrapper of the organism.
- It needs a single import `import { Tabs } from '@ds-name-to-define/tabs` to work. Instead of something like `import { Tabs, TabsTrigger, TabsList, etc... }`

<Title label="Composability" heading="h3" />

Composability comes from the fact that your organism is comprised of multiple components, instead of being a monolithic organism.

- You can intertwine the component's molecules with custom HTML for more flexibility.
- You can cherry-pick which molecules of the organism you will use.
- It avoids props drilling (an organism/molecule passing props to its children and so on).
